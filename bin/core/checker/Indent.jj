options{  JAVA_UNICODE_ESCAPE = true;  STATIC = false;  COMMON_TOKEN_ACTION = false;  TOKEN_FACTORY = "MyIndentToken";  JDK_VERSION = "1.5";  ERROR_REPORTING = false;}PARSER_BEGIN(IndentChecker)package core.checker;import java.io.*;import java.util.Vector;import core.rules.*;import core.warning.*;/**
 * Grammar to parse Java version 1.5
 * @author Sreenivasa Viswanadha - Simplified and enhanced for 1.5
 */public class IndentChecker extends Checker{  boolean chkIndent = true;  int l = 0;  boolean inSwitch = false;  static final char singleComment = 1;  static final char inComment = 3;  boolean inDo = false;  boolean inTry = false;  boolean inFor = false;  Token otherToken = null;  Token firstSpaces = null;  Token lastSpaces = null;  static final char newlineTok = 2;  boolean endOfLine = false;  String shouldNewLine = "";  boolean inLongLine = true;  boolean inWrapLine = false;  boolean inCode = false;  public IndentChecker(String fileName)  {    this (System.in);    try    {      ReInit(new FileInputStream(new File(fileName)));    }    catch (Exception e)    {      e.printStackTrace();    }  }  public void resetVariables()  {    warnings.clear();    chkIndent = true;    inSwitch = false;    l = 0; // l is level of braces
    inDo = false;    inTry = false;    otherToken = null;    firstSpaces = null;    lastSpaces = null;    endOfLine = false;    shouldNewLine = "";    inLongLine = true;    inWrapLine = false;    inCode = false;  }  public Vector < Warning > getWarnings()  {    return warnings;  }}PARSER_END(IndentChecker)void SpaChk(String correctSpaces) :{  Token t;  String addition = "";  String comparedString = "";  int noOfComment = 0;  int preEndLine =-1;  Vector < Integer > lines = new Vector < Integer > ();  firstSpaces = null;}{  (    (      (        LOOKAHEAD(< SPACES >)        {          if (getToken(0).kind != SPACES)          {            otherToken = getToken(0);            firstSpaces = null;          }          if (otherToken == null)          {            otherToken = new Token();            otherToken.endColumn = 0;          }        }        t = < SPACES >        {          //preEndLine = t.endLine;
          //Store lines of current group of spaces
          for (int i = t.beginLine + 1;; i++)          {            //Out(i+" ");
            if (t.image.endsWith("\n"))            {              if (i > t.endLine) break;            }            else            {              if (i > t.endLine - 1) break;            }            if (t.beginColumn != 1)            {              if (lines.size() != 0)              {                if (i != ((Integer) lines.get(lines.size() - 1)).intValue())                {                  lines.add(new Integer(i));                }              }              else              {                lines.add(new Integer(i));              }            }          }          //Out("|");
        }        {          if (firstSpaces == null)          {            firstSpaces = getToken(0);            if (otherToken.endColumn + 1 != firstSpaces.beginColumn)            { // have comment
              comparedString += singleComment;            }          }        }        {          if ((getToken(1).kind != SPACES) && (getToken(1).image != ""))          {            lastSpaces = getToken(0);            otherToken = getToken(1);            if (lastSpaces.endLine == otherToken.beginLine)            {              if (lastSpaces.endColumn + 1 != otherToken.beginColumn)              {                shouldNewLine = Character.toString(newlineTok);              }              else              {                shouldNewLine = "";              }            }            else            {              if (otherToken.beginColumn != 1)              {                shouldNewLine = Character.toString(newlineTok);              }              else              {                shouldNewLine = "";              }            }          }          else          {            shouldNewLine = "";          }        }        {          comparedString += (t.image + shouldNewLine + singleComment);        }      )*      {        if (firstSpaces != null)        {          comparedSpaceProcess(comparedString, correctSpaces, firstSpaces.beginLine, firstSpaces.beginColumn, lines);        }        else        {          if (correctSpaces.equals(""))          {}          else          {            comparedSpaceProcess("", correctSpaces, getToken(1).beginLine, getToken(1).beginColumn, lines);          }        }      }    )  )}void FormalCheck(String input, int beginLine, int subline, boolean chkIndent, boolean inWrapLine) :{}{  {    int currentLine = beginLine + subline;    StringBuilder sb = new StringBuilder(input);    // Comment Counting
    int noOfComment = 0;    for (int i = 0; i < sb.length(); i++)    {      if (sb.charAt(i) == singleComment)      {        noOfComment++;      }    }    if (noOfComment > 1)    {      Out("" + noOfComment + " ");      warnings.add(new WarningIndent(new Position(currentLine,       currentLine, - 1, - 1), WarningSpecify.INDENT_SINGLE_LINE_COMMENT, null));    }    // indentation
    String correctIndent = "";    if (!inWrapLine)    {      for (int i = 0; i < l; i++)      {        correctIndent += "    ";      }    }    else    {    }    String startSpaces = "";    boolean blankLine = false;    for (int i = 0; i < sb.length(); i++)    {      if (sb.charAt(i) == ' ')       startSpaces += " ";      else if (sb.charAt(i) == '\t')       startSpaces += "    ";      else      {        break;      }    }    if (!startSpaces.equals(correctIndent) && chkIndent && !blankLine)    {      String [ ] args = new String [ 2 ];      if (!inWrapLine)      {        args [ 0 ] = "false";        args [ 1 ] = String.valueOf(correctIndent.length() / 4);        warnings.add(new WarningIndent(new Position(currentLine,         currentLine, - 1, - 1), WarningSpecify.INDENT_INDENT, args));      }      else      {      }    }    if (subline != 0)    {      for (int i = 0; i < sb.length();)      {        if (sb.charAt(i) == ' ')         sb.deleteCharAt(i);        else         break;      }    }    if (sb.length() > 0)    {      // newline
      if (sb.charAt(sb.length() - 1) == newlineTok)      {        warnings.add(new WarningIndent(new Position(currentLine,         currentLine, - 1, - 1), WarningSpecify.INDENT_END_LINE_COMMENT, null));      }      // space at the end of line
      if (endOfLine && !chkIndent)      {        String temp = sb.toString();        if (temp.contains(" ") || temp.contains("\t"))        {          if (!temp.contains(String.valueOf(singleComment)))          {
            warnings.add(new WarningIndent(new Position(currentLine,             currentLine, - 1, - 1), WarningSpecify.INDENT_END_SPACE, null));          }        }      }    }    // space before comment
    if (subline == 0)    {      for (int i = 0; i < sb.length(); i++)      {        if (sb.charAt(i) == singleComment)        {          if (inCode)          {            if (i != 1)            {              String [ ] args = new String [ 1 ];              args [ 0 ] = String.valueOf(1);              warnings.add(new WarningIndent(new Position(              currentLine, currentLine, - 1, - 1), WarningSpecify.INDENT_COMMENT_SPACE, args));              for (int j = 0; i < sb.length();)              {                if (sb.charAt(j) == ' ')                 sb.deleteCharAt(j);                else                 break;              }            }          }          else          {            if (i != 0)            {              String [ ] args = new String [ 1 ];              args [ 0 ] = String.valueOf(0);              warnings.add(new WarningIndent(new Position(              currentLine, currentLine, - 1, - 1), WarningSpecify.INDENT_COMMENT_SPACE, args));              for (int j = 0; i < sb.length();)              {                if (sb.charAt(j) == ' ')                 sb.deleteCharAt(j);                else                 break;              }            }          }        }      }    }  }}void comparedSpaceProcess(String comparedSpace, String correctSpace, int beginLine, int beginColumn, Vector < Integer > lines) :{}{  {    StringBuilder sb = new StringBuilder(comparedSpace);    int lnNotConsidered = 0;    int blankLines = 0;    boolean chkIndent = false;    if (sb.length() > 0)    {      sb.deleteCharAt(sb.length() - 1);    }    comparedSpace = sb.toString();    int sublines = 0;    if (comparedSpace.contains("\n"))    {      endOfLine = true;    }    else    {      endOfLine = false;    }    String [ ] comparedSpaces = comparedSpace.split("\n", - 1);    String [ ] correctSpaces = correctSpace.split("\n", - 1);    if (correctSpace.contains("\n"))    {      blankLines = correctSpaces.length - 2;      //Out(blankLines+"\n");
    }    else    {      blankLines = 0;    }    int a = 0;    for (int i = 0; i < comparedSpaces.length; i++)    {      //if(i!=0) endOfLine = false;
      if (i != 0 && correctSpace.contains("\n"))      {        chkIndent = true;      }      else      {        chkIndent = false;      }      if (comparedSpaces [ i ].contains(String.valueOf(singleComment)))      {        FormalCheck(comparedSpaces [ i ], beginLine, sublines, chkIndent,         inWrapLine);      }      else      {        if (i == 0 || i == comparedSpaces.length - 1)        {          FormalCheck(comparedSpaces [ i ], beginLine, sublines,           chkIndent, inWrapLine);        }        else        {          if (i > blankLines && a < lines.size())          {            //Out(lines.size()+"|\n");
            String [ ] args = new String [ 0 ];            lnNotConsidered++;            warnings.add(new WarningIndent(new Position(lines.get(a),             lines.get(a), - 1, - 1), WarningSpecify.INDENT_NOT_BLANK_LINE, args));            a++;          }          else          {            a++;          }        }      }      sublines++;    }    // new line checking
    if (comparedSpaces.length > 0)    {      for (int i = 1; i < comparedSpaces.length; i++)      {        if (comparedSpaces [ i ].contains(Character.toString(singleComment)))        {          lnNotConsidered++;        }      }      if (!inCode)       lnNotConsidered++;      if (comparedSpaces.length - lnNotConsidered < correctSpaces.length)      {        if (blankLines > 0)        {          String [ ] args = new String [ 0 ];          warnings.add(new WarningIndent(new Position(beginLine,           beginLine, - 1, - 1), WarningSpecify.INDENT_BLANK_LINE, args));        }        else        {          String [ ] args = new String [ 0 ];          warnings.add(new WarningIndent(new Position(beginLine,           beginLine, - 1, - 1), WarningSpecify.INDENT_NEW_LINE, args));        }      }      if (inWrapLine)       lnNotConsidered++;      if (comparedSpaces.length - lnNotConsidered > correctSpaces.length)      {        String [ ] args = new String [ 0 ];        warnings.add(new WarningIndent(new Position(beginLine,         beginLine, - 1, - 1), WarningSpecify.INDENT_NOT_NEW_LINE, args));      }      if (comparedSpaces.length - lnNotConsidered == correctSpaces.length       && !endOfLine)      {        if (comparedSpaces [ 0 ].contains(Character.toString(singleComment)))        {          String [ ] args = new String [ 0 ];          warnings.add(new WarningIndent(new Position(beginLine,           beginLine, - 1, - 1), WarningSpecify.INDENT_INNER_COMMNET, args));        }        else        {          if (comparedSpaces [ 0 ].compareTo(correctSpaces [ 0 ]) != 0           && !inWrapLine)          {            String [ ] args = new String [ 2 ];            args [ 0 ] = String.valueOf(correctSpaces [ 0 ].length());            args [ 1 ] = getToken(1).image;            warnings.add(new WarningIndent(new Position(getToken(0).beginLine,             beginLine, getToken(0).beginColumn, - 1), WarningSpecify.INDENT_SPACE, args));          }        }      }    }  }}/* WHITE SPACE *//* COMMENTS */SKIP :{  //<COMMENT: <SINGLE_COMMENT>|<BLOCK_COMMENT> >
  < SINGLE_COMMENT :    "//"    (      (~[ "\n", "\r" ])    |      (        "\\"        (          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]        | [ "0"-"7" ] ([ "0"-"7" ])?        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]        )      )    )*     >|   < BLOCK_COMMENT : "/*" > : IN_MULTI_LINE_COMMENT|   < ETC : "@" < IDENTIFIER >>}< IN_FORMAL_COMMENT >SPECIAL_TOKEN :{  < FORMAL_COMMENT : "*/" > : DEFAULT}< IN_MULTI_LINE_COMMENT >SPECIAL_TOKEN :{  < MULTI_LINE_COMMENT : "*/" > : DEFAULT}< IN_FORMAL_COMMENT, IN_MULTI_LINE_COMMENT >SKIP :{  < ~[ ] >}/* RESERVED WORDS AND LITERALS */TOKEN :{  < SPACES :    (      " "    | "\n"    | "\t"    | "\r"    | "\f"    )+ >| < ABSTRACT : "abstract" >| < ASSERT : "assert" >| < BOOLEAN : "boolean" >| < BREAK : "break" >| < BYTE : "byte" >| < CASE : "case" >| < CATCH : "catch" >| < CHAR : "char" >| < CLASS : "class" >| < CONST : "const" >| < CONTINUE : "continue" >| < _DEFAULT : "default" >| < DO : "do" >| < DOUBLE : "double" >| < ELSE : "else" >| < ENUM : "enum" >| < EXTENDS : "extends" >| < FALSE : "false" >| < FINAL : "final" >| < FINALLY : "finally" >| < FLOAT : "float" >| < FOR : "for" >| < GOTO : "goto" >| < IF : "if" >| < IMPLEMENTS : "implements" >| < IMPORT : "import" >| < INSTANCEOF : "instanceof" >| < INT : "int" >| < INTERFACE : "interface" >| < LONG : "long" >| < NATIVE : "native" >| < NEW : "new" >| < NULL : "null" >| < PACKAGE : "package" >| < PRIVATE : "private" >| < PROTECTED : "protected" >| < PUBLIC : "public" >| < RETURN : "return" >| < SHORT : "short" >| < STATIC : "static" >| < STRICTFP : "strictfp" >| < SUPER : "super" >| < SWITCH : "switch" >| < SYNCHRONIZED : "synchronized" >| < THIS : "this" >| < THROW : "throw" >| < THROWS : "throws" >| < TRANSIENT : "transient" >| < TRUE : "true" >| < TRY : "try" >| < VOID : "void" >| < VOLATILE : "volatile" >| < WHILE : "while" >}/* LITERALS */TOKEN :{  < INTEGER_LITERAL :    < DECIMAL_LITERAL > ([ "l", "L" ])?  | < HEX_LITERAL > ([ "l", "L" ])?  | < OCTAL_LITERAL > ([ "l", "L" ])?     >|   < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >|   < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >|   < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >|   < FLOATING_POINT_LITERAL :    < DECIMAL_FLOATING_POINT_LITERAL >  | < HEXADECIMAL_FLOATING_POINT_LITERAL >    >|   < #DECIMAL_FLOATING_POINT_LITERAL :    ([ "0"-"9" ])+ "." ([ "0"-"9" ])* (< DECIMAL_EXPONENT >)? ([ "f", "F", "d", "D" ])?  | "." ([ "0"-"9" ])+ (< DECIMAL_EXPONENT >)? ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ])+ < DECIMAL_EXPONENT > ([ "f", "F", "d", "D" ])?  | ([ "0"-"9" ])+ (< DECIMAL_EXPONENT >)? [ "f", "F", "d", "D" ]     >|   < #DECIMAL_EXPONENT : [ "e", "E" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >|   < #HEXADECIMAL_FLOATING_POINT_LITERAL :    "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ (".")? < HEXADECIMAL_EXPONENT > ([ "f", "F", "d", "D" ])?  | "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])* "." ([ "0"-"9", "a"-"f", "A"-"F" ])+ < HEXADECIMAL_EXPONENT > ([ "f", "F", "d", "D" ])?     >|   < #HEXADECIMAL_EXPONENT : [ "p", "P" ] ([ "+", "-" ])? ([ "0"-"9" ])+ >|   < CHARACTER_LITERAL :    "'"    (      (~[ "'", "\\", "\n", "\r" ])    |      (        "\\"        (          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]        | [ "0"-"7" ] ([ "0"-"7" ])?        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]        )      )    )    "'"     >|   < STRING_LITERAL :    "\""    (      (~[ "\"", "\\", "\n", "\r" ])    |      (        "\\"        (          [ "n", "t", "b", "r", "f", "\\", "'", "\"" ]        | [ "0"-"7" ] ([ "0"-"7" ])?        | [ "0"-"3" ] [ "0"-"7" ] [ "0"-"7" ]        )      )    )*    "\""     >}

TOKEN :
{
  < IDENTIFIER: <LETTER> (<PART_LETTER>)* >
|
  < #LETTER:
      [  // all chars for which Character.isIdentifierStart is true
         "$",
         "A"-"Z",
         "_",
         "a"-"z",
         "\u00a2"-"\u00a5",
         "\u00aa",
         "\u00b5",
         "\u00ba",
         "\u00c0"-"\u00d6",
         "\u00d8"-"\u00f6",
         "\u00f8"-"\u021f",
         "\u0222"-"\u0233",
         "\u0250"-"\u02ad",
         "\u02b0"-"\u02b8",
         "\u02bb"-"\u02c1",
         "\u02d0"-"\u02d1",
         "\u02e0"-"\u02e4",
         "\u02ee",
         "\u037a",
         "\u0386",
         "\u0388"-"\u038a",
         "\u038c",
         "\u038e"-"\u03a1",
         "\u03a3"-"\u03ce",
         "\u03d0"-"\u03d7",
         "\u03da"-"\u03f3",
         "\u0400"-"\u0481",
         "\u048c"-"\u04c4",
         "\u04c7"-"\u04c8",
         "\u04cb"-"\u04cc",
         "\u04d0"-"\u04f5",
         "\u04f8"-"\u04f9",
         "\u0531"-"\u0556",
         "\u0559",
         "\u0561"-"\u0587",
         "\u05d0"-"\u05ea",
         "\u05f0"-"\u05f2",
         "\u0621"-"\u063a",
         "\u0640"-"\u064a",
         "\u0671"-"\u06d3",
         "\u06d5",
         "\u06e5"-"\u06e6",
         "\u06fa"-"\u06fc",
         "\u0710",
         "\u0712"-"\u072c",
         "\u0780"-"\u07a5",
         "\u0905"-"\u0939",
         "\u093d",
         "\u0950",
         "\u0958"-"\u0961",
         "\u0985"-"\u098c",
         "\u098f"-"\u0990",
         "\u0993"-"\u09a8",
         "\u09aa"-"\u09b0",
         "\u09b2",
         "\u09b6"-"\u09b9",
         "\u09dc"-"\u09dd",
         "\u09df"-"\u09e1",
         "\u09f0"-"\u09f3",
         "\u0a05"-"\u0a0a",
         "\u0a0f"-"\u0a10",
         "\u0a13"-"\u0a28",
         "\u0a2a"-"\u0a30",
         "\u0a32"-"\u0a33",
         "\u0a35"-"\u0a36",
         "\u0a38"-"\u0a39",
         "\u0a59"-"\u0a5c",
         "\u0a5e",
         "\u0a72"-"\u0a74",
         "\u0a85"-"\u0a8b",
         "\u0a8d",
         "\u0a8f"-"\u0a91",
         "\u0a93"-"\u0aa8",
         "\u0aaa"-"\u0ab0",
         "\u0ab2"-"\u0ab3",
         "\u0ab5"-"\u0ab9",
         "\u0abd",
         "\u0ad0",
         "\u0ae0",
         "\u0b05"-"\u0b0c",
         "\u0b0f"-"\u0b10",
         "\u0b13"-"\u0b28",
         "\u0b2a"-"\u0b30",
         "\u0b32"-"\u0b33",
         "\u0b36"-"\u0b39",
         "\u0b3d",
         "\u0b5c"-"\u0b5d",
         "\u0b5f"-"\u0b61",
         "\u0b85"-"\u0b8a",
         "\u0b8e"-"\u0b90",
         "\u0b92"-"\u0b95",
         "\u0b99"-"\u0b9a",
         "\u0b9c",
         "\u0b9e"-"\u0b9f",
         "\u0ba3"-"\u0ba4",
         "\u0ba8"-"\u0baa",
         "\u0bae"-"\u0bb5",
         "\u0bb7"-"\u0bb9",
         "\u0c05"-"\u0c0c",
         "\u0c0e"-"\u0c10",
         "\u0c12"-"\u0c28",
         "\u0c2a"-"\u0c33",
         "\u0c35"-"\u0c39",
         "\u0c60"-"\u0c61",
         "\u0c85"-"\u0c8c",
         "\u0c8e"-"\u0c90",
         "\u0c92"-"\u0ca8",
         "\u0caa"-"\u0cb3",
         "\u0cb5"-"\u0cb9",
         "\u0cde",
         "\u0ce0"-"\u0ce1",
         "\u0d05"-"\u0d0c",
         "\u0d0e"-"\u0d10",
         "\u0d12"-"\u0d28",
         "\u0d2a"-"\u0d39",
         "\u0d60"-"\u0d61",
         "\u0d85"-"\u0d96",
         "\u0d9a"-"\u0db1",
         "\u0db3"-"\u0dbb",
         "\u0dbd",
         "\u0dc0"-"\u0dc6",
         "\u0e01"-"\u0e30",
         "\u0e32"-"\u0e33",
         "\u0e3f"-"\u0e46",
         "\u0e81"-"\u0e82",
         "\u0e84",
         "\u0e87"-"\u0e88",
         "\u0e8a",
         "\u0e8d",
         "\u0e94"-"\u0e97",
         "\u0e99"-"\u0e9f",
         "\u0ea1"-"\u0ea3",
         "\u0ea5",
         "\u0ea7",
         "\u0eaa"-"\u0eab",
         "\u0ead"-"\u0eb0",
         "\u0eb2"-"\u0eb3",
         "\u0ebd",
         "\u0ec0"-"\u0ec4",
         "\u0ec6",
         "\u0edc"-"\u0edd",
         "\u0f00",
         "\u0f40"-"\u0f47",
         "\u0f49"-"\u0f6a",
         "\u0f88"-"\u0f8b",
         "\u1000"-"\u1021",
         "\u1023"-"\u1027",
         "\u1029"-"\u102a",
         "\u1050"-"\u1055",
         "\u10a0"-"\u10c5",
         "\u10d0"-"\u10f6",
         "\u1100"-"\u1159",
         "\u115f"-"\u11a2",
         "\u11a8"-"\u11f9",
         "\u1200"-"\u1206",
         "\u1208"-"\u1246",
         "\u1248",
         "\u124a"-"\u124d",
         "\u1250"-"\u1256",
         "\u1258",
         "\u125a"-"\u125d",
         "\u1260"-"\u1286",
         "\u1288",
         "\u128a"-"\u128d",
         "\u1290"-"\u12ae",
         "\u12b0",
         "\u12b2"-"\u12b5",
         "\u12b8"-"\u12be",
         "\u12c0",
         "\u12c2"-"\u12c5",
         "\u12c8"-"\u12ce",
         "\u12d0"-"\u12d6",
         "\u12d8"-"\u12ee",
         "\u12f0"-"\u130e",
         "\u1310",
         "\u1312"-"\u1315",
         "\u1318"-"\u131e",
         "\u1320"-"\u1346",
         "\u1348"-"\u135a",
         "\u13a0"-"\u13f4",
         "\u1401"-"\u166c",
         "\u166f"-"\u1676",
         "\u1681"-"\u169a",
         "\u16a0"-"\u16ea",
         "\u1780"-"\u17b3",
         "\u17db",
         "\u1820"-"\u1877",
         "\u1880"-"\u18a8",
         "\u1e00"-"\u1e9b",
         "\u1ea0"-"\u1ef9",
         "\u1f00"-"\u1f15",
         "\u1f18"-"\u1f1d",
         "\u1f20"-"\u1f45",
         "\u1f48"-"\u1f4d",
         "\u1f50"-"\u1f57",
         "\u1f59",
         "\u1f5b",
         "\u1f5d",
         "\u1f5f"-"\u1f7d",
         "\u1f80"-"\u1fb4",
         "\u1fb6"-"\u1fbc",
         "\u1fbe",
         "\u1fc2"-"\u1fc4",
         "\u1fc6"-"\u1fcc",
         "\u1fd0"-"\u1fd3",
         "\u1fd6"-"\u1fdb",
         "\u1fe0"-"\u1fec",
         "\u1ff2"-"\u1ff4",
         "\u1ff6"-"\u1ffc",
         "\u203f"-"\u2040",
         "\u207f",
         "\u20a0"-"\u20af",
         "\u2102",
         "\u2107",
         "\u210a"-"\u2113",
         "\u2115",
         "\u2119"-"\u211d",
         "\u2124",
         "\u2126",
         "\u2128",
         "\u212a"-"\u212d",
         "\u212f"-"\u2131",
         "\u2133"-"\u2139",
         "\u2160"-"\u2183",
         "\u3005"-"\u3007",
         "\u3021"-"\u3029",
         "\u3031"-"\u3035",
         "\u3038"-"\u303a",
         "\u3041"-"\u3094",
         "\u309d"-"\u309e",
         "\u30a1"-"\u30fe",
         "\u3105"-"\u312c",
         "\u3131"-"\u318e",
         "\u31a0"-"\u31b7",
         "\u3400"-"\u4db5",
         "\u4e00"-"\u9fa5",
         "\ua000"-"\ua48c",
         "\uac00"-"\ud7a3",
         "\uf900"-"\ufa2d",
         "\ufb00"-"\ufb06",
         "\ufb13"-"\ufb17",
         "\ufb1d",
         "\ufb1f"-"\ufb28",
         "\ufb2a"-"\ufb36",
         "\ufb38"-"\ufb3c",
         "\ufb3e",
         "\ufb40"-"\ufb41",
         "\ufb43"-"\ufb44",
         "\ufb46"-"\ufbb1",
         "\ufbd3"-"\ufd3d",
         "\ufd50"-"\ufd8f",
         "\ufd92"-"\ufdc7",
         "\ufdf0"-"\ufdfb",
         "\ufe33"-"\ufe34",
         "\ufe4d"-"\ufe4f",
         "\ufe69",
         "\ufe70"-"\ufe72",
         "\ufe74",
         "\ufe76"-"\ufefc",
         "\uff04",
         "\uff21"-"\uff3a",
         "\uff3f",
         "\uff41"-"\uff5a",
         "\uff65"-"\uffbe",
         "\uffc2"-"\uffc7",
         "\uffca"-"\uffcf",
         "\uffd2"-"\uffd7",
         "\uffda"-"\uffdc",
         "\uffe0"-"\uffe1",
         "\uffe5"-"\uffe6"
      ]
  >
|
  < #PART_LETTER:
      [  // all chars for which Character.isIdentifierPart is true
         "\u0000"-"\u0008",
         "\u000e"-"\u001b",
         "$",
         "0"-"9",
         "A"-"Z",
         "_",
         "a"-"z",
         "\u007f"-"\u009f",
         "\u00a2"-"\u00a5",
         "\u00aa",
         "\u00b5",
         "\u00ba",
         "\u00c0"-"\u00d6",
         "\u00d8"-"\u00f6",
         "\u00f8"-"\u021f",
         "\u0222"-"\u0233",
         "\u0250"-"\u02ad",
         "\u02b0"-"\u02b8",
         "\u02bb"-"\u02c1",
         "\u02d0"-"\u02d1",
         "\u02e0"-"\u02e4",
         "\u02ee",
         "\u0300"-"\u034e",
         "\u0360"-"\u0362",
         "\u037a",
         "\u0386",
         "\u0388"-"\u038a",
         "\u038c",
         "\u038e"-"\u03a1",
         "\u03a3"-"\u03ce",
         "\u03d0"-"\u03d7",
         "\u03da"-"\u03f3",
         "\u0400"-"\u0481",
         "\u0483"-"\u0486",
         "\u048c"-"\u04c4",
         "\u04c7"-"\u04c8",
         "\u04cb"-"\u04cc",
         "\u04d0"-"\u04f5",
         "\u04f8"-"\u04f9",
         "\u0531"-"\u0556",
         "\u0559",
         "\u0561"-"\u0587",
         "\u0591"-"\u05a1",
         "\u05a3"-"\u05b9",
         "\u05bb"-"\u05bd",
         "\u05bf",
         "\u05c1"-"\u05c2",
         "\u05c4",
         "\u05d0"-"\u05ea",
         "\u05f0"-"\u05f2",
         "\u0621"-"\u063a",
         "\u0640"-"\u0655",
         "\u0660"-"\u0669",
         "\u0670"-"\u06d3",
         "\u06d5"-"\u06dc",
         "\u06df"-"\u06e8",
         "\u06ea"-"\u06ed",
         "\u06f0"-"\u06fc",
         "\u070f"-"\u072c",
         "\u0730"-"\u074a",
         "\u0780"-"\u07b0",
         "\u0901"-"\u0903",
         "\u0905"-"\u0939",
         "\u093c"-"\u094d",
         "\u0950"-"\u0954",
         "\u0958"-"\u0963",
         "\u0966"-"\u096f",
         "\u0981"-"\u0983",
         "\u0985"-"\u098c",
         "\u098f"-"\u0990",
         "\u0993"-"\u09a8",
         "\u09aa"-"\u09b0",
         "\u09b2",
         "\u09b6"-"\u09b9",
         "\u09bc",
         "\u09be"-"\u09c4",
         "\u09c7"-"\u09c8",
         "\u09cb"-"\u09cd",
         "\u09d7",
         "\u09dc"-"\u09dd",
         "\u09df"-"\u09e3",
         "\u09e6"-"\u09f3",
         "\u0a02",
         "\u0a05"-"\u0a0a",
         "\u0a0f"-"\u0a10",
         "\u0a13"-"\u0a28",
         "\u0a2a"-"\u0a30",
         "\u0a32"-"\u0a33",
         "\u0a35"-"\u0a36",
         "\u0a38"-"\u0a39",
         "\u0a3c",
         "\u0a3e"-"\u0a42",
         "\u0a47"-"\u0a48",
         "\u0a4b"-"\u0a4d",
         "\u0a59"-"\u0a5c",
         "\u0a5e",
         "\u0a66"-"\u0a74",
         "\u0a81"-"\u0a83",
         "\u0a85"-"\u0a8b",
         "\u0a8d",
         "\u0a8f"-"\u0a91",
         "\u0a93"-"\u0aa8",
         "\u0aaa"-"\u0ab0",
         "\u0ab2"-"\u0ab3",
         "\u0ab5"-"\u0ab9",
         "\u0abc"-"\u0ac5",
         "\u0ac7"-"\u0ac9",
         "\u0acb"-"\u0acd",
         "\u0ad0",
         "\u0ae0",
         "\u0ae6"-"\u0aef",
         "\u0b01"-"\u0b03",
         "\u0b05"-"\u0b0c",
         "\u0b0f"-"\u0b10",
         "\u0b13"-"\u0b28",
         "\u0b2a"-"\u0b30",
         "\u0b32"-"\u0b33",
         "\u0b36"-"\u0b39",
         "\u0b3c"-"\u0b43",
         "\u0b47"-"\u0b48",
         "\u0b4b"-"\u0b4d",
         "\u0b56"-"\u0b57",
         "\u0b5c"-"\u0b5d",
         "\u0b5f"-"\u0b61",
         "\u0b66"-"\u0b6f",
         "\u0b82"-"\u0b83",
         "\u0b85"-"\u0b8a",
         "\u0b8e"-"\u0b90",
         "\u0b92"-"\u0b95",
         "\u0b99"-"\u0b9a",
         "\u0b9c",
         "\u0b9e"-"\u0b9f",
         "\u0ba3"-"\u0ba4",
         "\u0ba8"-"\u0baa",
         "\u0bae"-"\u0bb5",
         "\u0bb7"-"\u0bb9",
         "\u0bbe"-"\u0bc2",
         "\u0bc6"-"\u0bc8",
         "\u0bca"-"\u0bcd",
         "\u0bd7",
         "\u0be7"-"\u0bef",
         "\u0c01"-"\u0c03",
         "\u0c05"-"\u0c0c",
         "\u0c0e"-"\u0c10",
         "\u0c12"-"\u0c28",
         "\u0c2a"-"\u0c33",
         "\u0c35"-"\u0c39",
         "\u0c3e"-"\u0c44",
         "\u0c46"-"\u0c48",
         "\u0c4a"-"\u0c4d",
         "\u0c55"-"\u0c56",
         "\u0c60"-"\u0c61",
         "\u0c66"-"\u0c6f",
         "\u0c82"-"\u0c83",
         "\u0c85"-"\u0c8c",
         "\u0c8e"-"\u0c90",
         "\u0c92"-"\u0ca8",
         "\u0caa"-"\u0cb3",
         "\u0cb5"-"\u0cb9",
         "\u0cbe"-"\u0cc4",
         "\u0cc6"-"\u0cc8",
         "\u0cca"-"\u0ccd",
         "\u0cd5"-"\u0cd6",
         "\u0cde",
         "\u0ce0"-"\u0ce1",
         "\u0ce6"-"\u0cef",
         "\u0d02"-"\u0d03",
         "\u0d05"-"\u0d0c",
         "\u0d0e"-"\u0d10",
         "\u0d12"-"\u0d28",
         "\u0d2a"-"\u0d39",
         "\u0d3e"-"\u0d43",
         "\u0d46"-"\u0d48",
         "\u0d4a"-"\u0d4d",
         "\u0d57",
         "\u0d60"-"\u0d61",
         "\u0d66"-"\u0d6f",
         "\u0d82"-"\u0d83",
         "\u0d85"-"\u0d96",
         "\u0d9a"-"\u0db1",
         "\u0db3"-"\u0dbb",
         "\u0dbd",
         "\u0dc0"-"\u0dc6",
         "\u0dca",
         "\u0dcf"-"\u0dd4",
         "\u0dd6",
         "\u0dd8"-"\u0ddf",
         "\u0df2"-"\u0df3",
         "\u0e01"-"\u0e3a",
         "\u0e3f"-"\u0e4e",
         "\u0e50"-"\u0e59",
         "\u0e81"-"\u0e82",
         "\u0e84",
         "\u0e87"-"\u0e88",
         "\u0e8a",
         "\u0e8d",
         "\u0e94"-"\u0e97",
         "\u0e99"-"\u0e9f",
         "\u0ea1"-"\u0ea3",
         "\u0ea5",
         "\u0ea7",
         "\u0eaa"-"\u0eab",
         "\u0ead"-"\u0eb9",
         "\u0ebb"-"\u0ebd",
         "\u0ec0"-"\u0ec4",
         "\u0ec6",
         "\u0ec8"-"\u0ecd",
         "\u0ed0"-"\u0ed9",
         "\u0edc"-"\u0edd",
         "\u0f00",
         "\u0f18"-"\u0f19",
         "\u0f20"-"\u0f29",
         "\u0f35",
         "\u0f37",
         "\u0f39",
         "\u0f3e"-"\u0f47",
         "\u0f49"-"\u0f6a",
         "\u0f71"-"\u0f84",
         "\u0f86"-"\u0f8b",
         "\u0f90"-"\u0f97",
         "\u0f99"-"\u0fbc",
         "\u0fc6",
         "\u1000"-"\u1021",
         "\u1023"-"\u1027",
         "\u1029"-"\u102a",
         "\u102c"-"\u1032",
         "\u1036"-"\u1039",
         "\u1040"-"\u1049",
         "\u1050"-"\u1059",
         "\u10a0"-"\u10c5",
         "\u10d0"-"\u10f6",
         "\u1100"-"\u1159",
         "\u115f"-"\u11a2",
         "\u11a8"-"\u11f9",
         "\u1200"-"\u1206",
         "\u1208"-"\u1246",
         "\u1248",
         "\u124a"-"\u124d",
         "\u1250"-"\u1256",
         "\u1258",
         "\u125a"-"\u125d",
         "\u1260"-"\u1286",
         "\u1288",
         "\u128a"-"\u128d",
         "\u1290"-"\u12ae",
         "\u12b0",
         "\u12b2"-"\u12b5",
         "\u12b8"-"\u12be",
         "\u12c0",
         "\u12c2"-"\u12c5",
         "\u12c8"-"\u12ce",
         "\u12d0"-"\u12d6",
         "\u12d8"-"\u12ee",
         "\u12f0"-"\u130e",
         "\u1310",
         "\u1312"-"\u1315",
         "\u1318"-"\u131e",
         "\u1320"-"\u1346",
         "\u1348"-"\u135a",
         "\u1369"-"\u1371",
         "\u13a0"-"\u13f4",
         "\u1401"-"\u166c",
         "\u166f"-"\u1676",
         "\u1681"-"\u169a",
         "\u16a0"-"\u16ea",
         "\u1780"-"\u17d3",
         "\u17db",
         "\u17e0"-"\u17e9",
         "\u180b"-"\u180e",
         "\u1810"-"\u1819",
         "\u1820"-"\u1877",
         "\u1880"-"\u18a9",
         "\u1e00"-"\u1e9b",
         "\u1ea0"-"\u1ef9",
         "\u1f00"-"\u1f15",
         "\u1f18"-"\u1f1d",
         "\u1f20"-"\u1f45",
         "\u1f48"-"\u1f4d",
         "\u1f50"-"\u1f57",
         "\u1f59",
         "\u1f5b",
         "\u1f5d",
         "\u1f5f"-"\u1f7d",
         "\u1f80"-"\u1fb4",
         "\u1fb6"-"\u1fbc",
         "\u1fbe",
         "\u1fc2"-"\u1fc4",
         "\u1fc6"-"\u1fcc",
         "\u1fd0"-"\u1fd3",
         "\u1fd6"-"\u1fdb",
         "\u1fe0"-"\u1fec",
         "\u1ff2"-"\u1ff4",
         "\u1ff6"-"\u1ffc",
         "\u200c"-"\u200f",
         "\u202a"-"\u202e",
         "\u203f"-"\u2040",
         "\u206a"-"\u206f",
         "\u207f",
         "\u20a0"-"\u20af",
         "\u20d0"-"\u20dc",
         "\u20e1",
         "\u2102",
         "\u2107",
         "\u210a"-"\u2113",
         "\u2115",
         "\u2119"-"\u211d",
         "\u2124",
         "\u2126",
         "\u2128",
         "\u212a"-"\u212d",
         "\u212f"-"\u2131",
         "\u2133"-"\u2139",
         "\u2160"-"\u2183",
         "\u3005"-"\u3007",
         "\u3021"-"\u302f",
         "\u3031"-"\u3035",
         "\u3038"-"\u303a",
         "\u3041"-"\u3094",
         "\u3099"-"\u309a",
         "\u309d"-"\u309e",
         "\u30a1"-"\u30fe",
         "\u3105"-"\u312c",
         "\u3131"-"\u318e",
         "\u31a0"-"\u31b7",
         "\u3400"-"\u4db5",
         "\u4e00"-"\u9fa5",
         "\ua000"-"\ua48c",
         "\uac00"-"\ud7a3",
         "\uf900"-"\ufa2d",
         "\ufb00"-"\ufb06",
         "\ufb13"-"\ufb17",
         "\ufb1d"-"\ufb28",
         "\ufb2a"-"\ufb36",
         "\ufb38"-"\ufb3c",
         "\ufb3e",
         "\ufb40"-"\ufb41",
         "\ufb43"-"\ufb44",
         "\ufb46"-"\ufbb1",
         "\ufbd3"-"\ufd3d",
         "\ufd50"-"\ufd8f",
         "\ufd92"-"\ufdc7",
         "\ufdf0"-"\ufdfb",
         "\ufe20"-"\ufe23",
         "\ufe33"-"\ufe34",
         "\ufe4d"-"\ufe4f",
         "\ufe69",
         "\ufe70"-"\ufe72",
         "\ufe74",
         "\ufe76"-"\ufefc",
         "\ufeff",
         "\uff04",
         "\uff10"-"\uff19",
         "\uff21"-"\uff3a",
         "\uff3f",
         "\uff41"-"\uff5a",
         "\uff65"-"\uffbe",
         "\uffc2"-"\uffc7",
         "\uffca"-"\uffcf",
         "\uffd2"-"\uffd7",
         "\uffda"-"\uffdc",
         "\uffe0"-"\uffe1",
         "\uffe5"-"\uffe6",
         "\ufff9"-"\ufffb"
      ]
  >
}

/* SEPARATORS */
TOKEN :{  < TOKEN_IDENTIFIER : < CLASS >>}TOKEN :{  < LPAREN : "(" >| < RPAREN : ")" >| < LBRACE : "{" >| < RBRACE : "}" >| < LBRACKET : "[" >| < RBRACKET : "]" >| < SEMICOLON : ";" >| < COMMA : "," >| < DOT : "." >| < AT : "@" >}/* OPERATORS */TOKEN :{  < ASSIGN : "=" >| < LT : "<" >| < BANG : "!" >| < TILDE : "~" >| < HOOK : "?" >| < COLON : ":" >| < EQ : "==" >| < LE : "<=" >| < GE : ">=" >| < NE : "!=" >| < SC_OR : "||" >| < SC_AND : "&&" >| < INCR : "++" >| < DECR : "--" >| < PLUS : "+" >| < MINUS : "-" >| < STAR : "*" >| < SLASH : "/" >| < BIT_AND : "&" >| < BIT_OR : "|" >| < XOR : "^" >| < REM : "%" >| < LSHIFT : "<<" >| < PLUSASSIGN : "+=" >| < MINUSASSIGN : "-=" >| < STARASSIGN : "*=" >| < SLASHASSIGN : "/=" >| < ANDASSIGN : "&=" >| < ORASSIGN : "|=" >| < XORASSIGN : "^=" >| < REMASSIGN : "%=" >| < LSHIFTASSIGN : "<<=" >| < RSIGNEDSHIFTASSIGN : ">>=" >| < RUNSIGNEDSHIFTASSIGN : ">>>=" >| < ELLIPSIS : "..." >| < ASIGN_OPERATOR :    "="  | "*="  | "/="  | "%="  | "+="  | "-="  | "<<="  | ">>="  | ">>>="  | "&="  | "^="  | "|=" >}/* >'s need special attention due to generics syntax. */TOKEN :{  < RUNSIGNEDSHIFT : ">>>" >  {    matchedToken.kind = GT;    ((MyIndentToken) matchedToken).realKind = RUNSIGNEDSHIFT;    input_stream.backup(2);    matchedToken.image = ">";  }| < RSIGNEDSHIFT : ">>" >  {    matchedToken.kind = GT;    ((MyIndentToken) matchedToken).realKind = RSIGNEDSHIFT;    input_stream.backup(1);    matchedToken.image = ">";  }| < GT : ">" >}/*****************************************
 * THE JAVA LANGUAGE GRAMMAR STARTS HERE *
 *****************************************//*
 * Program structuring syntax follows.
 */void CompilationUnit() :{}{  SpaChk("")  [    LOOKAHEAD(5)    PackageDeclaration()  ]  ImportDeclaration()  (    TypeDeclaration()  )+  (< "" >)?   (< STUFF_TO_IGNORE : ~[ ] >)?   < EOF >}void PackageDeclaration() :{}{  {    inCode = true;  }  "package" SpaChk(" ")  (    Name()  )*  ";" OutNewLine("\n")}void ImportDeclaration() :{}{  {    inCode = true;  }  (    "import" SpaChk(" ") [ "static" SpaChk(" ") ]    (      Name()    )*    SpaChk("") [ "." SpaChk("") "*" ] ";"    (      LOOKAHEAD((< SPACES >)* "import")      OutNewLine("")    |      (        OutNewLine("\n")      )    )  )*}/*
 * Modifiers. We match all modifiers in a single rule to reduce the chances of
 * syntax errors for simple modifier mistakes. It will also enable us to give
 * better error messages.
 */int Modifiers() :{  int modifiers = 0;}{  (    LOOKAHEAD(2)    (      "public" SpaChk(" ")      {        modifiers |= ModifierSet.PUBLIC;      }    |       "static" SpaChk(" ")      {        modifiers |= ModifierSet.STATIC;      }    |       "protected" SpaChk(" ")      {        modifiers |= ModifierSet.PROTECTED;      }    |       "private" SpaChk(" ")      {        modifiers |= ModifierSet.PRIVATE;      }    |       "final" SpaChk(" ")      {        modifiers |= ModifierSet.FINAL;      }    |       "abstract" SpaChk(" ")      {        modifiers |= ModifierSet.ABSTRACT;      }    |       "synchronized" SpaChk(" ")      {        modifiers |= ModifierSet.SYNCHRONIZED;      }    |       "native" SpaChk(" ")      {        modifiers |= ModifierSet.NATIVE;      }    |       "transient" SpaChk(" ")      {        modifiers |= ModifierSet.TRANSIENT;      }    |       "volatile" SpaChk(" ")      {        modifiers |= ModifierSet.VOLATILE;      }    |       "strictfp" SpaChk(" ")      {        modifiers |= ModifierSet.STRICTFP;      }    )  )*  {    return modifiers;  }}/*
 * Declaration syntax follows.
 */void TypeDeclaration() :{  {    inCode = true;  }  int modifiers;}{  (    ";"  |     modifiers = Modifiers()    (      ClassOrInterfaceDeclaration(modifiers)    |       EnumDeclaration(modifiers)    |       AnnotationTypeDeclaration(modifiers)    )  )}void ClassOrInterfaceDeclaration(int modifiers) :{  boolean isInterface = false;}{  (    "class"  | "interface"    {      isInterface = true;    }  )  SpaChk(" ")   < IDENTIFIER >   SpaChk(" ")   [ TypeParameters() ]   [ ExtendsList(isInterface) SpaChk(" ") ]   [ ImplementsList(isInterface) SpaChk(" ") ]   ClassOrInterfaceBody(isInterface)}void ExtendsList(boolean isInterface) :{  boolean extendsMoreThanOne = false;}{  "extends" SpaChk(" ") ClassOrInterfaceType()  (    "," ClassOrInterfaceType()    {      extendsMoreThanOne = true;    }  )*  {    if (extendsMoreThanOne && !isInterface)     throw new ParseException("A class cannot extend more than one other class");  }}void ImplementsList(boolean isInterface) :{}{  "implements" SpaChk(" ") ClassOrInterfaceType()  (    LOOKAHEAD((< SPACES >)* ",")    SpaChk("")    (      "," SpaChk(" ") ClassOrInterfaceType()    )*  |     Out("")  )  {    if (isInterface)     throw new ParseException("An interface cannot implement other interfaces");  }}void EnumDeclaration(int modifiers) :{}{  "enum" < IDENTIFIER >   [ ImplementsList(false) ]   EnumBody()}void EnumBody() :{}{  "{"  [    EnumConstant()    (      LOOKAHEAD(2)      "," EnumConstant()    )*  ]  [ "," ]  [    ";"    (      ClassOrInterfaceBodyDeclaration(false)    )*  ]  "}"}void EnumConstant() :{}{  Modifiers() < IDENTIFIER > [ Arguments() ] [ ClassOrInterfaceBody(false) ]}void TypeParameters() :{}{  "<" SpaChk("") TypeParameter() SpaChk("")  (    "," SpaChk(" ") TypeParameter() SpaChk("")  )*  ">"}void TypeParameter() :{}{  < IDENTIFIER > [ TypeBound() ]}void TypeBound() :{}{  "extends" ClassOrInterfaceType()  (    "&" ClassOrInterfaceType()  )*}void ClassOrInterfaceBody(boolean isInterface) :{}{  "{" OutNewLine("{")  (    ClassOrInterfaceBodyDeclaration(isInterface)  )*  "}"  (    LOOKAHEAD((< SPACES >)* < EOF >)    (      SpaChk("")    )  |     LOOKAHEAD((< SPACES >)* "}")    OutNewLine("}")  |    (      OutNewLine("\n")    )  )}void ClassOrInterfaceBodyDeclaration(boolean isInterface) :{  boolean isNestedInterface = false;  int modifiers;}{  (    LOOKAHEAD(4)    Initializer()    {      if (isInterface)       throw new ParseException("An interface cannot have initializers");    }  |     modifiers = Modifiers() // Just get all the modifiers out of the way. If you want to do
    // more checks, pass the modifiers down to the member
    (      ClassOrInterfaceDeclaration(modifiers)    |       EnumDeclaration(modifiers)    |       LOOKAHEAD([ TypeParameters() ] < IDENTIFIER > "(")      ConstructorDeclaration()    |       LOOKAHEAD((Type()    | Name()) (< SPACES >)* < IDENTIFIER > (< SPACES >)*       ("[" (< SPACES >)* "]" (< SPACES >)*)*       (","    | "="    | ";")      )      FieldDeclaration(modifiers)    |       MethodDeclaration(modifiers)    |       AnnotationTypeDeclaration(modifiers)    )  |     ";"  )}void FieldDeclaration(int modifiers) :{}{  // Modifiers are already matched in the caller
  Type() SpaChk(" ") VariableDeclarator() SpaChk("")  (    "," SpaChk(" ") VariableDeclarator() SpaChk("")  )*  ";" OutNewLine(";")}void VariableDeclarator() :{}{  VariableDeclaratorId()  (    LOOKAHEAD((< SPACES >)* "=")    SpaChk(" ") "=" SpaChk(" ") VariableInitializer()  |     Out("")  )}void Array() :{}{  SpaChk("") "[" SpaChk("")  (    Expression() SpaChk("")  )*  "]"}void VariableDeclaratorId() :{}{  < IDENTIFIER >  (    LOOKAHEAD(6)    Array()  )*}void VariableInitializer() :{}{  ArrayInitializer()|   Expression()}void ArrayInitializer() :{}{  "{"  [    VariableInitializer() SpaChk("")    (      LOOKAHEAD(5)      "," SpaChk(" ") VariableInitializer()    )*  ]  [ SpaChk("") "," ] "}"}void MethodDeclaration(int modifiers) :{}{  // Modifiers already matched in the caller!
  [ TypeParameters() ]   ResultType() SpaChk(" ")   MethodDeclarator()  (    LOOKAHEAD((< SPACES >)* "throws")    SpaChk(" ") "throws" SpaChk(" ") NameList()  |     Out("")  )  (    LOOKAHEAD((< SPACES >)* ";")    SpaChk("") ";"  |     Block()  )}void MethodDeclarator() :{}{  < IDENTIFIER > SpaChk("") "(" SpaChk("")  (    FormalParameters()  )*  SpaChk("") ")" ("[" "]")*}void FormalParameters() :{}{  FormalParameter()  (    LOOKAHEAD(3)    SpaChk("") "," SpaChk(" ")  )*}void FormalParameter() :{}{  // danson, added
  //          [ "final" | Annotation() ]
  // See Java Language Specification, 3rd Edition, section 8.4.1
  Modifiers()  [    (      "final"    | Annotation()    )    SpaChk(" ")  ]  Type() SpaChk(" ") [ "..." SpaChk(" ") ] VariableDeclaratorId()}void ConstructorDeclaration() :{}{  [ TypeParameters() SpaChk("") ]   // Modifiers matched in the caller
  < IDENTIFIER > "(" SpaChk("")  (    FormalParameters()  )*  SpaChk("") ")"  (    LOOKAHEAD((< SPACES >)* "throws")    SpaChk(" ") "throws" SpaChk(" ") NameList() SpaChk(" ")  |     SpaChk(" ")  )  "{" OutNewLine("{")  [    LOOKAHEAD(ExplicitConstructorInvocation())    ExplicitConstructorInvocation()  ]  (    BlockStatement()  )*  "}" OutNewLine("}")}void ExplicitConstructorInvocation() :{}{  (< IDENTIFIER > ".")*  [    LOOKAHEAD(2)    "this" "."  ]  [ TypeArguments() ]  (    "this"  | "super"  )  Arguments() SpaChk("") ";" OutNewLine(";")}void Initializer() :{}{  [ "static" ] Block()}/*
 * Type, name and expression syntax follows.
 */void Type() :{}{  LOOKAHEAD(4)  ReferenceType()|   PrimitiveType()}void ReferenceType() :{}{  PrimitiveType()  (    LOOKAHEAD(4)    Array()  )*|  (    ClassOrInterfaceType()  )  (    LOOKAHEAD(4)    Array()  )*}void ClassOrInterfaceType() :{}{  < IDENTIFIER >  [    LOOKAHEAD((< SPACES >)* "<" (< SPACES >)* TypeArgument())    SpaChk("") TypeArguments()  ]  (    LOOKAHEAD((< SPACES >)* "." (< IDENTIFIER >))    "." SpaChk("") (< IDENTIFIER >)    [      LOOKAHEAD((< SPACES >)* "<" (< SPACES >)* TypeArgument())      SpaChk("") TypeArguments() SpaChk(" ")    ]  )*}void TypeArguments() :{}{  "<" SpaChk("") TypeArgument() SpaChk("")  (    "," SpaChk("") TypeArgument() SpaChk("")  )*  ">"}void TypeArgument() :{}{  ReferenceType()|   "?" [ WildcardBounds() ]}void WildcardBounds() :{}{  "extends" ReferenceType()|   "super" ReferenceType()}void PrimitiveType() :{}{  "boolean"|   "char"|   "byte"|   "short"|   "int"|   "long"|   "float"|   "double"}void ResultType() :{}{  "void"|   Type()}void Name() :/*
 * A lookahead of 2 is required below since "Name" can be followed
 * by a ".*" when used in the context of an "ImportDeclaration".
 */{}{  < IDENTIFIER >  (    LOOKAHEAD((< SPACES >)* "." (< SPACES >)* < IDENTIFIER >)    SpaChk("") "." SpaChk("")  |     Out("")  )}void NameList() :{}{  (    Name()  )*  (    ","    (      Name()    )*  )*}/*
 * Expression syntax follows.
 */void Expression() :/*
 * This expansion has been written this way instead of:
 *   Assignment() | ConditionalExpression()
 * for performance reasons.
 * However, it is a weakening of the grammar for it allows the LHS of
 * assignments to be any conditional expression whereas it can only be
 * a primary expression.  Consider adding a semantic predicate to work
 * around this.
 */{}{  ConditionalExpression()  (    LOOKAHEAD((< SPACES >)* < ASIGN_OPERATOR >)    (      AssignmentOperator() Expression()    )*  |     Out("")  )}//
void AssignmentOperator() :{}{  SpaChk(" ")  (    "="  | "*="  | "/="  | "%="  | "+="  | "-="  | "<<="  | ">>="  | ">>>="  | "&="  | "^="  | "|="  )  SpaChk(" ")}//
void ConditionalExpression() :{}{  ConditionalOrExpression()  [    LOOKAHEAD((< SPACES >)* "?")    SpaChk(" ") "?" SpaChk(" ") Expression() SpaChk(" ") ":" SpaChk(" ") ConditionalExpression()  ]}//
void ConditionalOrExpression() :{}{  ConditionalAndExpression()  (    LOOKAHEAD((< SPACES >)* "||")    SpaChk(" ") "||" SpaChk(" ") ConditionalAndExpression()  )*}//
void ConditionalAndExpression() :{}{  InclusiveOrExpression()  (    LOOKAHEAD((< SPACES >)* "&&")    SpaChk(" ") "&&" SpaChk(" ") InclusiveOrExpression()  )*}//
void InclusiveOrExpression() :{}{  ExclusiveOrExpression()  (    LOOKAHEAD((< SPACES >)* "|")    SpaChk(" ") "|" SpaChk(" ") ExclusiveOrExpression()  )*}//
void ExclusiveOrExpression() :{}{  AndExpression()  (    LOOKAHEAD((< SPACES >)* "^")    SpaChk(" ") "^" SpaChk(" ") AndExpression()  )*}//
void AndExpression() :{}{  EqualityExpression()  (    LOOKAHEAD((< SPACES >)* "&")    SpaChk(" ") "&" SpaChk(" ") EqualityExpression()  )*}//
void EqualityExpression() :{}{  InstanceOfExpression()  (    LOOKAHEAD((< SPACES >)* ("=="  | "!="))    SpaChk(" ")    (      "=="    | "!="    )    SpaChk(" ") InstanceOfExpression()  )*}//
void InstanceOfExpression() :{}{  RelationalExpression()  [    LOOKAHEAD((< SPACES >)* "instanceof")    SpaChk(" ") "instanceof" SpaChk(" ") Type()  ]}//
void RelationalExpression() :{}{  ShiftExpression()  (    LOOKAHEAD((< SPACES >)* ("<"  | ">"  | "<="  | ">="))    SpaChk(" ")    (      "<"    | ">"    | "<="    | ">="    )    SpaChk(" ") ShiftExpression()  )*}//
void ShiftExpression() :{}{  AdditiveExpression()  (    LOOKAHEAD((< SPACES >)* ("<<"  | ">>"  | ">>>"))    SpaChk(" ")    (      "<<"    | ">>"    | ">>>"    )    SpaChk(" ") AdditiveExpression()  )*}//
void AdditiveExpression() :{}{  MultiplicativeExpression()  (    LOOKAHEAD((< SPACES >)* ("+"  | "-"  | "+="  | "-="  | "="))    SpaChk(" ")    (      "+"    | "-"    | "+="    | "-="    | "="    )    SpaChk(" ") MultiplicativeExpression()  )*}void MultiplicativeExpression() :{}{  UnaryExpression()  (    LOOKAHEAD((< SPACES >)* ("*"  | "/"  | "%"))    SpaChk(" ")    (      "*"    | "/"    | "%"    )    SpaChk(" ") UnaryExpression()  )*}void UnaryExpression() :{}{  (    "+"  | "-"  )  SpaChk("") UnaryExpression()|   PreIncrementExpression()|   PreDecrementExpression()|   UnaryExpressionNotPlusMinus()}void PreIncrementExpression() :{}{  "++" SpaChk("") PrimaryExpression()}void PreDecrementExpression() :{}{  "--" SpaChk("") PrimaryExpression()}void UnaryExpressionNotPlusMinus() :{}{  (    "~" SpaChk("")  | "!" SpaChk("")  )  UnaryExpression()|   LOOKAHEAD(CastLookahead())  CastExpression()|   PostfixExpression()}// This production is to determine lookahead only.  The LOOKAHEAD specifications
// below are not used, but they are there just to indicate that we know about
// this.
void CastLookahead() :{}{  LOOKAHEAD((< SPACES >)* "(" (< SPACES >)* PrimitiveType())  "(" PrimitiveType()|   LOOKAHEAD((< SPACES >)* "(" (< SPACES >)* (Name())* (< SPACES >)* "[")  "("  (    Name()  )*  "[" "]"|   "("  (    Name()  )*  ")"  (    "~"  | "!"  | "("  | < IDENTIFIER >  | "this"  | "super"  | "new"  | Literal()  )}void PostfixExpression() :{}{  PrimaryExpression()  [    "++"  | "--"  ]}void CastExpression() :{}{  LOOKAHEAD("(" (< SPACES >)* PrimitiveType())  "(" SpaChk("") Type() SpaChk("") ")" SpaChk("") UnaryExpression()|   "(" SpaChk("") Type() SpaChk("") ")" SpaChk("") UnaryExpressionNotPlusMinus()}void PrimaryExpression() :{}{  PrimaryPrefix()  (    LOOKAHEAD(2)    PrimarySuffix()  )*}void MemberSelector() :{}{  "." TypeArguments() < IDENTIFIER >}void PrimaryPrefix() :{}{  Literal()|   LOOKAHEAD((< IDENTIFIER > (< SPACES >)* ".")* (< SPACES >)* "this")  (    < IDENTIFIER > SpaChk("") "." SpaChk("")  )*  "this"|   "super" "." < IDENTIFIER >|   // danson, added this part to support a construct like:
  //   Buffer.super.setDirty(true);
  // See Java Language Specification, 3rd edition, section 15.11.2.
  LOOKAHEAD(ClassOrInterfaceType() "." "super" "." < IDENTIFIER >)  ClassOrInterfaceType() "." "super" "." < IDENTIFIER >|   "(" SpaChk("") Expression() SpaChk("") ")"|   AllocationExpression()|   LOOKAHEAD(ResultType() (< SPACES >)* "." (< SPACES >)* "class")  ResultType() SpaChk("") "." SpaChk("") "class" SpaChk("")|  (    Name()  )+}void PrimarySuffix() :{}{  LOOKAHEAD("." "super" ".")  "." "super"|   LOOKAHEAD("." "this")  "." "this"|   LOOKAHEAD(2)  "." AllocationExpression()|   LOOKAHEAD(3)  MemberSelector()|   "[" SpaChk("") Expression() SpaChk("") "]"|   "." < IDENTIFIER >|   Arguments()}void Literal() :{}{  < INTEGER_LITERAL >|   < FLOATING_POINT_LITERAL >|   < CHARACTER_LITERAL >|   < STRING_LITERAL >|   BooleanLiteral()|   NullLiteral()}void BooleanLiteral() :{}{  "true"|   "false"}void NullLiteral() :{}{  "null"}void Arguments() :{}{  SpaChk("") "("   SpaChk("")  (    ArgumentList()  )*  SpaChk("") ")"}void ArgumentList() :{}{  Expression()  (    LOOKAHEAD((< SPACES >)* ",")    (      SpaChk("") "," SpaChk(" ")    )*  |     Out("")  )}void AllocationExpression() :{}{  LOOKAHEAD((< SPACES >)* "new" (< SPACES >)* Type() (< SPACES >)* (ArrayDimsAndInits())*)  "new" SpaChk(" ") Type() SpaChk("")  (    ArrayDimsAndInits()  )*|   "new" SpaChk(" ") ClassOrInterfaceType() [ TypeArguments() ]  (    ArrayDimsAndInits()  |     Arguments() [ ClassOrInterfaceBody(false) ]  )}/*
 * The third LOOKAHEAD specification below is to parse to PrimarySuffix
 * if there is an expression between the "[...]".
 */void ArrayDimsAndInits() :{}{  ArrayInitializer()}/*
 * Statement syntax follows.
 */void Statement() :{}{  (    LOOKAHEAD((< SPACES >)* < IDENTIFIER > (< SPACES >)* ":")    LabeledStatement()  |     AssertStatement()  |     Block()  |     EmptyStatement()  |     StatementExpression() SpaChk("") ";" OutNewLine(";")  |     SwitchStatement()  |     IfStatement()  |     WhileStatement()  |     DoStatement()  |     ForStatement()  |     BreakStatement()  |     ContinueStatement()  |     ReturnStatement()  |     ThrowStatement()  |     SynchronizedStatement()  |     TryStatement()  )}void AssertStatement() :{}{  "assert" Expression() [ ":" Expression() ] ";"}void LabeledStatement() :{}{  < IDENTIFIER > SpaChk("") ":" OutNewLine(":")   Statement()}void Block() :{}{  SpaChk(" ") "{" OutNewLine("{")  (    BlockStatement()  )*  "}" OutNewLine("}")}void BlockStatement() :{}{  LOOKAHEAD((< SPACES >)* Modifiers() (< SPACES >)* Type() (< SPACES >)* < IDENTIFIER >)  LocalVariableDeclaration() ";" OutNewLine(";")|   Statement()|   ClassOrInterfaceDeclaration(0)}void LocalVariableDeclaration() :{}{  Modifiers() Type() SpaChk(" ") VariableDeclarator() SpaChk("")  (    "," SpaChk(" ") VariableDeclarator() SpaChk("")  )*}void EmptyStatement() :{}{  ";" OutNewLine(";")}void StatementExpression() :/*
 * The last expansion of this production accepts more than the legal
 * Java expansions for StatementExpression.  This expansion does not
 * use PostfixExpression for performance reasons.
 */{}{  PreIncrementExpression()|   PreDecrementExpression()|   PrimaryExpression()  (    LOOKAHEAD((< SPACES >)* ("++"  | "--"))    SpaChk("")    (      "++"    | "--"    )  |     LOOKAHEAD((< SPACES >)* AssignmentOperator())    AssignmentOperator() Expression()  |     Out("")  )}void SwitchStatement() :{  int temp = l;  inSwitch = true;}{  "switch" SpaChk(" ") "(" SpaChk("") Expression() SpaChk("") ")" SpaChk(" ") "{" OutNewLine("{")  (    SwitchLabel()    (      BlockStatement()    )*  )*  "}" OutNewLine("}")}void SwitchLabel() :{}{  (    "case"    {      l++;    }    SpaChk(" ") Expression() SpaChk(" ") ":"  |     "default"    {      l++;    }    SpaChk(" ") ":"  )  OutNewLine("")}void IfStatement() :/*
 * The disambiguating algorithm of JavaCC automatically binds dangling
 * else's to the innermost if statement.  The LOOKAHEAD specification
 * is to tell JavaCC that we know what we are doing.
 */{}{  "if" SpaChk(" ") "(" SpaChk("")   Expression() SpaChk("") ")"  (    LOOKAHEAD((< SPACES >)* "{")    (      Block()    )  |    (      {        l++;      }      OutNewLine("")      {        l--;      }      Statement()    )  ) //SpaChk(" ")
  (    LOOKAHEAD("else")    "else"    (      LOOKAHEAD((< SPACES >)* "{")      Block()    |      (        {          l++;        }        OutNewLine("")        {          l--;        }        Statement()      )    )  |     Out("")  )}void WhileStatement() :{}{  "while" SpaChk(" ") "(" SpaChk("") Expression() SpaChk("") ")"  (    LOOKAHEAD((< SPACES >)* "{")    Statement()  |     SpaChk(" ") Statement()  )}void DoStatement() :{}{  "do" Statement() "while" "(" Expression() ")" SpaChk("") ";" OutNewLine(";")}void ForStatement() :{}{  "for" SpaChk(" ") "(" SpaChk("") [ ForInit() ] ";" SpaChk(" ") [ Expression() ] ";" SpaChk(" ") [ ForUpdate() ] SpaChk("") ")"  (    LOOKAHEAD((< SPACES >)* "{")    Statement()  |    {      l++;    }    OutNewLine(")")    {      l--;    }    Statement()  )}void ForInit() :{}{  LOOKAHEAD(Modifiers() Type() (< SPACES >)* < IDENTIFIER >)  LocalVariableDeclaration()|   StatementExpressionList()}void StatementExpressionList() :{}{  StatementExpression()  (    "," StatementExpression()  )*}void ForUpdate() :{}{  StatementExpressionList()}void BreakStatement() :{}{  "break"  (    LOOKAHEAD((< SPACES >)* < IDENTIFIER >)    SpaChk(" ") [ < IDENTIFIER > ]  |     Out("")  )  SpaChk("") ";" OutNewLine(";")}void ContinueStatement() :{}{  "continue" [ < IDENTIFIER > ] SpaChk("") ";" OutNewLine(";")}void ReturnStatement() :{}{  "return"  (    LOOKAHEAD((< SPACES >)* ";")    SpaChk("")  |     SpaChk(" ")  )  [ Expression() SpaChk("") ] ";" OutNewLine(";")}void ThrowStatement() :{}{  "throw" SpaChk(" ") Expression() SpaChk("") ";" OutNewLine(";")}void SynchronizedStatement() :{}{  "synchronized" "(" Expression() ")" Block()}void TryStatement() :/*
 * Semantic check required here to make sure that at least one
 * finally/catch is present.
 */{  inTry = true;}{  "try" Block()  (    "catch" SpaChk(" ") "(" SpaChk("") FormalParameter() SpaChk("") ")" Block()  )*  [ "finally" Block() ]}/* We use productions to match >>>, >> and > so that we can keep the
 * type declaration syntax with generics clean
 */void RUNSIGNEDSHIFT() :{}{  (    LOOKAHEAD({ getToken(1).kind == GT &&     ((MyIndentToken) getToken(1)).realKind == RUNSIGNEDSHIFT })    ">" ">" ">"  )}void RSIGNEDSHIFT() :{}{  (    LOOKAHEAD({ getToken(1).kind == GT &&     ((MyIndentToken) getToken(1)).realKind == RSIGNEDSHIFT })    ">" ">"  )}/* Annotation syntax follows. */void Annotation() :{}{  LOOKAHEAD("@" (Name())* "(" (< IDENTIFIER > "="| ")"))  NormalAnnotation()|   LOOKAHEAD("@" (Name())* "(")  SingleMemberAnnotation()|   MarkerAnnotation()}void NormalAnnotation() :{}{  "@"  (    Name()  )*  "(" [ MemberValuePairs() ] ")"}void MarkerAnnotation() :{}{  "@"  (    Name()  )*}void SingleMemberAnnotation() :{}{  "@"  (    Name()  )*  "(" MemberValue() ")"}void MemberValuePairs() :{}{  MemberValuePair()  (    "," MemberValuePair()  )*}void MemberValuePair() :{}{  < IDENTIFIER > "=" MemberValue()}void MemberValue() :{}{  Annotation()|   MemberValueArrayInitializer()|   ConditionalExpression()}void MemberValueArrayInitializer() :{}{  "{"  (    MemberValue()    (      LOOKAHEAD(2)      "," MemberValue()    )*    [ "," ]  )?  "}"}/* Annotation Types. */void AnnotationTypeDeclaration(int modifiers) :{}{  "@" "interface" < IDENTIFIER > AnnotationTypeBody()}void AnnotationTypeBody() :{}{  "{"  (    AnnotationTypeMemberDeclaration()  )*  "}"}void AnnotationTypeMemberDeclaration() :{  int modifiers;}{  modifiers = Modifiers()  (    LOOKAHEAD(Type() < IDENTIFIER > "(")    Type() < IDENTIFIER > "(" ")" [ DefaultValue() ] ";"  |     ClassOrInterfaceDeclaration(modifiers)  |     EnumDeclaration(modifiers)  |     AnnotationTypeDeclaration(modifiers)  |     FieldDeclaration(modifiers)  )|   (";")}void DefaultValue() :{}{  "default" MemberValue()}void Out(String s) :{}{  {    System.out.print(s);  }}void OutWhiteLine() :{}{  SpaChk("\n")}void FirstLine(String s) :{  String a = "\n";}{  //(LOOKAHEAD((< SPACES >)* ("else")){l--;}|Out(""))
  (    LOOKAHEAD((< SPACES >)* ("case"  | "default"))    {      l--;    }  | Out("")  )  (    LOOKAHEAD((< SPACES >)* ("}"))    {      l--;    }  | Out("")  )  {    if (s.compareTo("\n") == 0)    {      a += "\n";    }    if (s.compareTo("{") == 0)    {      l++;    }    for (int i = 0; i < l; i++)    {      a += "    ";    }    SpaChk(a);  }}void OutNewLine(String s) :{}{  LOOKAHEAD((< SPACES >)* "else")  /*Out(s)*/  {    if (s.equals("}"))    {      SpaChk(" ");    }    else    {      FirstLine(s);    }  }|   LOOKAHEAD((< SPACES >)* "while")  /*Out(s)*/  {    if (s.equals("}") && inDo)    {      SpaChk(" ");      inDo = false;    }    else    {      FirstLine(s);    }  }|   LOOKAHEAD((< SPACES >)* "catch")  /*Out(s)*/  {    if (s.equals("}") && inTry)    {      SpaChk(" ");      inTry = false;    }    else    {      FirstLine(s);    }  }|   /*Out(s)*/  FirstLine(s)}